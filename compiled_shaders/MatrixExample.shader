/* * 
 ** This file is automatically generated from glslify-godot. 
 ** Do not edit this file. 
 **  
 ** Date: 2024-08-12T12:40:05 
 * */ 
shader_type spatial;
render_mode unshaded;

// FREYA HOLMÃ‰R MADE THIS! 
//
// I only ported it to godot!

const int DATA_BITS_1540259130[10] = {
	0xEBFB,0xFFFC,
	0xA89B,0x21B4,
	0xABBF,0xF9FC,
	0xAA12,0x69A4,
	0xEBF3,0xF9E5
};

const int po10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000};

float DrawDigit(ivec2 px,  int digit)
{
    if (px.x < 0 || px.x > 2 || px.y < 0 || px.y > 4)
        return 0.0; // pixel out of bounds
    int xId = (digit == -1) ? 18 : 31 - (3 * digit + px.x);
    return float(0 != (DATA_BITS_1540259130[(4 - px.y) * 2 + int(xId < 16)] & (1 << (xId % 16))));
}

// indexed like: XXX.0123
void GetDecimalSymbolAt( float v, const int i, const int decimalCount, out int symbol, out float opacity)
{
    // hide if outside the decimal range
    if (i > min(decimalCount - 1, 6))
    {
        symbol = 0;
        opacity = 0.0;
        return;
    }
    // get the i:th decimal
    float scale = float(po10[i + 1]);
    float scaledF = abs(v) * scale;
    symbol = int(scaledF) % 10;

    // fade trailing zeroes
    opacity = (fract(scaledF / 10.0) != 0.0) ? 1.0 : 0.5;
}

// indexed like: 210.XXX
void GetIntSymbolAt( float v, int i, out int symbol, out float opacity)
{
    // don't render more than 9 digits
    if (i <= 9)
    {
         int scale = po10[i];
         float vAbs = abs(v);
        // digits
        if (vAbs >= float(scale))
        {
             int it = int(floor(vAbs));
             int rem = it / scale;
            symbol = rem % 10;
            opacity = 1.0;
            return;
        }
        // minus symbol
        if ((v < 0.0) && (vAbs * 10.0 >= float(scale)))
        {
            symbol = -1;
            opacity = 1.0;
            return;
        }
    }
    // leading zeroes
    symbol = 0;
    opacity = 0.0;
}

// Get the digit at the given index of a floating point number
// with -45.78, then with a given dIndex:
// [-3] = - (digit -1)
// [-2] = 4
// [-1] = 5
// [ 0] = . (digit 10)
// [ 1] = 7
// [ 2] = 8
void GetSymbolAtPositionInFloat(float number, int dIndex, int decimalCount, out int symbol, out float opacity)
{
    opacity = 1.0;
    if (dIndex == 0)
        symbol = 10; // period
    else if (dIndex > 0)
        GetDecimalSymbolAt(number, dIndex - 1, decimalCount, symbol, opacity);
    else
        GetIntSymbolAt(number, -dIndex - 1, symbol, opacity);
}

// Given a pixel coordinate pxCoord, draws a number at pxPos
float DrawNumberAtPxPos(vec2 pxCoord, vec2 pxPos, float number, float fontScale, int decimalCount)
{
    ivec2 p = ivec2(floor((pxCoord - pxPos) / fontScale));
    // p.y += 0; // 0 = bottom aligned, 2 = vert. center aligned, 5 = top aligned
    // p.x += 0; // 0 = integers are directly to the left, decimal separator and decimals, to the right
    if (p.y < 0 || p.y > 4)
        return 0.0; // out of bounds vertically
    // shift placement to make it tighter around the decimal separator
    int shift = 0;
    if (p.x > 1) // decimal digits
        p.x += 1;
    else if (p.x < 0) // integer digits
    {
        p.x += -1;
    }

    int SEP = 4; // separation between characters
    int dIndex = int(floor(float(p.x) / float(SEP))); // the digit index to read
    float opacity;
    int digit;
    GetSymbolAtPositionInFloat(number, dIndex, decimalCount, /*out*/ digit, /*out*/ opacity);

    ivec2 pos = ivec2(dIndex * SEP + shift, 0);
    return opacity * DrawDigit(p - pos, digit);
}

vec3 DrawMat4AtPxPos(vec2 pxCoord, vec2 pxPos, mat4 mat, float scale, int decimalCount) {
	pxCoord+=vec2(50.0,-50.0)*scale;
	float acc = 0.0;
	float sep= 20.0 + 15.0 * scale;
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-0.0 * sep, 0.0 * sep), mat[0][0], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-0.0 * sep, 1.0 * sep), mat[1][0], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-0.0 * sep, 2.0 * sep), mat[2][0], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-0.0 * sep, 3.0 * sep), mat[3][0], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-1.0 * sep, 0.0 * sep), mat[0][1], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-1.0 * sep, 1.0 * sep), mat[1][1], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-1.0 * sep, 2.0 * sep), mat[2][1], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-1.0 * sep, 3.0 * sep), mat[3][1], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-2.0 * sep, 0.0 * sep), mat[0][2], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-2.0 * sep, 1.0 * sep), mat[1][2], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-2.0 * sep, 2.0 * sep), mat[2][2], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-2.0 * sep, 3.0 * sep), mat[3][2], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-3.0 * sep, 0.0 * sep), mat[0][3], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-3.0 * sep, 1.0 * sep), mat[1][3], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-3.0 * sep, 2.0 * sep), mat[2][3], scale,decimalCount);
	acc += DrawNumberAtPxPos(pxCoord, pxPos - vec2(-3.0 * sep, 3.0 * sep), mat[3][3], scale,decimalCount);
	return vec3(acc);
}

vec2 clipToPixel(vec4 clip, vec2 view_size)
{
    vec2 ndc = vec2(clip.x, clip.y) / clip.w;
    ndc = (ndc + 1.0) / 2.0;
    return ndc * view_size; 
}

vec2 worldToPixel(vec3 worldPos, mat4 proj_mat, mat4 inv_cam_mat, vec2 view_size) {
	vec4 clip = proj_mat * inv_cam_mat * vec4(worldPos, 1.0);
	return clipToPixel(clip, view_size);
}

void fragment() {
	ALBEDO = vec3(
			DrawMat4AtPxPos(
				FRAGCOORD.xy, 
				worldToPixel(WORLD_MATRIX[3].xyz,PROJECTION_MATRIX,INV_CAMERA_MATRIX,VIEWPORT_SIZE),
				WORLD_MATRIX,
				1.0,
				3
			)
		);
}
